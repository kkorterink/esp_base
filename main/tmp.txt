

y
I (28380) base_main: HTTP GET Status = 200, content_length = 291
I (28380) base_main: 7b 0a 20 20 22 61 72 67 73 22 3a 20 7b 0a 20 20
I (28380) base_main: 20 20 22 65 73 70 22 3a 20 22 22 0a 20 20 7d 2c
I (28390) base_main: 20 0a 20 20 22 68 65 61 64 65 72 73 22 3a 20 7b
I (28390) base_main: 0a 20 20 20 20 22 43 6f 6e 74 65 6e 74 2d 4c 65
I (28400) base_main: 6e 67 74 68 22 3a 20 22 30 22 2c 20 0a 20 20 20
I (28410) base_main: 20 22 48 6f 73 74 22 3a 20 22 68 74 74 70 62 69
I (28410) base_main: 6e 2e 6f 72 67 22 2c 20 0a 20 20 20 20 22 55 73
I (28420) base_main: 65 72 2d 41 67 65 6e 74 22 3a 20 22 45 53 50 33
I (28420) base_main: 32 20 48 54 54 50 20 43 6c 69 65 6e 74 2f 31 2e
I (28430) base_main: 30 22 2c 20 0a 20 20 20 20 22 58 2d 41 6d 7a 6e
I (28440) base_main: 2d 54 72 61 63 65 2d 49 64 22 3a 20 22 52 6f 6f
I (28440) base_main: 74 3d 31 2d 36 37 33 66 33 37 39 35 2d 30 33 31
I (28450) base_main: 61 36 66 37 35 35 65 37 64 39 63 35 36 30 66 30
I (28450) base_main: 37 61 64 36 33 22 0a 20 20 7d 2c 20 0a 20 20 22
I (28460) base_main: 6f 72 69 67 69 6e 22 3a 20 22 31 39 37 2e 38 39
I (28470) base_main: 2e 39 36 2e 31 36 31 22 2c 20 0a 20 20 22 75 72
I (28470) base_main: 6c 22 3a 20 22 68 74 74 70 3a 2f 2f 68 74 74 70
I (28480) base_main: 62 69 6e 2e 6f 72 67 2f 67 65 74 3f 65 73 70 22
I (28480) base_main: 0a 7d 0a
ok y-cmd


esp_http_client_event_t         *evt 
    esp_http_client_handle_t    client;
        esp_http_data_t         *response;
            int64_t             content_length;


esp_http_client_event_t {
    esp_http_client_event_id_t event_id;
        HTTP_EVENT_ERROR = 0,
        HTTP_EVENT_ON_CONNECTED,
        HTTP_EVENT_HEADERS_SENT,
        HTTP_EVENT_HEADER_SENT = HTTP_EVENT_HEADERS_SENT,
        HTTP_EVENT_ON_HEADER,
        HTTP_EVENT_ON_DATA,
        HTTP_EVENT_ON_FINISH,
        HTTP_EVENT_DISCONNECTED,
        HTTP_EVENT_REDIRECT,
    esp_http_client_handle_t client;
        int                         redirect_counter;
        int                         max_redirection_count;
        int                         max_authorization_retries;
        int                         process_again;
        struct http_parser          *parser;
        struct http_parser_settings *parser_settings;
        esp_transport_list_handle_t transport_list;
        esp_transport_handle_t      transport;
        esp_http_data_t             *request;
        esp_http_data_t             *response;
            http_header_handle_t        headers;
            esp_http_buffer_t           *buffer;
            int                         status_code;
            int64_t                     content_length;         //
            int                         chunk_length;
            int                         data_offset;
            int64_t                     data_process;
            int                         method;
            bool                        is_chunked;
        void                        *user_data;
        esp_http_auth_data_t        *auth_data;
        char                        *post_data;
        char                        *location;
        char                        *auth_header;
        char                        *current_header_key;
        char                        *current_header_value;
        int                         post_len;
        connection_info_t           connection_info;
        bool                        is_chunk_complete;
        esp_http_state_t            state;
        http_event_handle_cb        event_handler;
        int                         timeout_ms;
        int                         buffer_size_rx;
        int                         buffer_size_tx;
        bool                        disable_auto_redirect;
        esp_http_client_event_t     event;
        int                         data_written_index;
        int                         data_write_left;
        bool                        first_line_prepared;
        int                         header_index;
        bool                        is_async;
        esp_transport_keep_alive_t  keep_alive_cfg;
        struct ifreq                *if_name;
        unsigned                    cache_data_in_fetch_hdr: 1;
      #ifdef CONFIG_ESP_TLS_CLIENT_SESSION_TICKETS
        session_ticket_state_t      session_ticket_state;
      #endif
    void *data;
    int data_len;
    void *user_data;
    char *header_key;
    char *header_value;
}



esp_netif_t* esp_netif_create_default_wifi_sta(void)
{
    esp_netif_config_t cfg = ESP_NETIF_DEFAULT_WIFI_STA();
    esp_netif_t *netif = esp_netif_new(&cfg);
    assert(netif);
    ESP_ERROR_CHECK(esp_netif_attach_wifi_station(netif));
    ESP_ERROR_CHECK(esp_wifi_set_default_wifi_sta_handlers());
    return netif;
}


void example_wifi_start(void)
{
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));

    esp_netif_inherent_config_t esp_netif_config = ESP_NETIF_INHERENT_DEFAULT_WIFI_STA();
    // Warning: the interface desc is used in tests to capture actual connection details (IP, gw, mask)
    esp_netif_config.if_desc = EXAMPLE_NETIF_DESC_STA;
    esp_netif_config.route_prio = 128;
    s_example_sta_netif = esp_netif_create_wifi(WIFI_IF_STA, &esp_netif_config);
    esp_wifi_set_default_wifi_sta_handlers();

    ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM));
    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
    ESP_ERROR_CHECK(esp_wifi_start());
}


